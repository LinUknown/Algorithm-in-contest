把问题转化成前一项的子问题， 是DP的精髓，
这个题目就是 ： 当我下一项大于前一项， 就不符合条件， 所以这项的D， 需要在前一项的D 加1 .

在此总结下DP 。 
1、连续类  连续类考虑D【i】项和D【i-1】项的关系，例如连续最大子序列， 看i-1之前的是否大于0 大于就加上， 否则自立门户。
2、非连续类  考虑是否带上前面 。  
 


#include <iostream>

using namespace std;
int a[30005];
int d[30005];
int main()
{
    int n;
    while(cin>>n)
    {
        for(int i=1;i<=n;i++) {cin>>a[i];d[i]=1;}

        for(int i=2;i<=n;i++)
            for(int j=1;j<i;j++)
        {
            if(a[j]<a[i]&&d[i]<d[j]+1)
                d[i]=d[j]+1;

        }
        int m=-100;
        for(int i=1;i<=n;i++)
            if(m<d[i])
        m=d[i];
        cout<<m<<endl;
    }

    return 0;
}
